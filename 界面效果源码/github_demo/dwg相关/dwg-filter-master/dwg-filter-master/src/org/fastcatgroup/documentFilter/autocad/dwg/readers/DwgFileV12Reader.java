/*
 * Created on 09-ene-2007
 *
 * gvSIG. Sistema de Informaci�n Geogr�fica de la Generalitat Valenciana
 *
 * Copyright (C) 2004 IVER T.I. and Generalitat Valenciana.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,USA.
 *
 * For more information, contact:
 *
 *  Generalitat Valenciana
 *   Conselleria d'Infraestructures i Transport
 *   Av. Blasco Ib��ez, 50
 *   46010 VALENCIA
 *   SPAIN
 *
 *      +34 963862235
 *   gvsig@gva.es
 *      www.gvsig.gva.es
 *
 *    or
 *
 *   IVER T.I. S.A
 *   Salamanca 50
 *   46005 Valencia
 *   Spain
 *
 *   +34 963163400
 *   dac@iver.es
 */
package org.fastcatgroup.documentFilter.autocad.dwg.readers;

import java.awt.geom.Point2D;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;

import org.fastcatgroup.documentFilter.autocad.dwg.CorruptedDwgEntityException;
import org.fastcatgroup.documentFilter.autocad.dwg.DwgFile;
import org.fastcatgroup.documentFilter.autocad.dwg.DwgHandleReference;
import org.fastcatgroup.documentFilter.autocad.dwg.DwgObject;
import org.fastcatgroup.documentFilter.autocad.dwg.DwgObjectFactory;
import org.fastcatgroup.documentFilter.autocad.dwg.IDwgBlockMember;
import org.fastcatgroup.documentFilter.autocad.dwg.IDwgPolyline;
import org.fastcatgroup.documentFilter.autocad.dwg.IDwgVertex;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgArc;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgBlockHeader;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgCircle;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgEndblk;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgInsert;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgLayer;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgLine;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgMeshPolyline;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgPFacePolyline;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgPoint;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgPolyline2D;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgPolyline3D;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgSeqend;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgSolid;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgText;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgVertex2D;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgVertex3D;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgVertexPFace;
import org.fastcatgroup.documentFilter.autocad.dwg.objects.DwgVertexPFaceFace;


/**
 * Reads version 12 dwg files.
 * 
 * DWG 13 and DWG 12 are very different formats (nor do DWG 13-14 and 2000).
 * Thats the reason why this IDwgFileReader is very different from the rest. 
 * 
 * Documentation of reverse engineering of the format:
 * 	http://www.iwriteiam.nl/DWG12.html
 * 
 * @author azabala
 * 
 */
public class DwgFileV12Reader implements IDwgFileReader{

	private DwgFile dwgFile;
	private ByteBuffer bb;
	ArrayList readers = new ArrayList();
	private boolean r13 = false;
	int index = 0;
	
	ArrayList blocks = new ArrayList();
	
	
	/**
	 * While DwgBlock is a DWG entity, readed from the DWG entities
	 * section, a Block is an entry in the BLOCK Section of DWG 12 format.
	 * 
	 * Block has block name attribute (like DwgBlock), but its most
	 * important attribute is its order in the Block section.
	 * 
	 * Inserts has a short number that we think is the order of its
	 * referred block in the block table (the only approach to fech
	 * the block of an insert)
	 * */
	class Block {
		/*
        |----------|--------------------------------------------|
        | 1        | This is an anonymous Block generated by    |
        |          | hatching, associative dimensioning, other  |
        |          | internal operations, or an application     |
        |----------|--------------------------------------------|
        | 2        | This Block has Attributes                  |
        |----------|--------------------------------------------|
        | 4        | This Block is an external reference (Xref) |
        |----------|--------------------------------------------|
        | 8        | not used                                   |
        |----------|--------------------------------------------|
        | 16       | This Block is externally dependent         |
        |----------|--------------------------------------------|
        | 32       | This is a resolved external reference, or  |
        |          | dependent of an external reference         |
        |----------|--------------------------------------------|
        | 64       | This definition is referenced              |
        +-------------------------------------------------------+
        */
		byte flag;
		String name;
		short used;
		
		byte b1;
		short w1;
		byte b2;
		short w3;
		short crc;
	}
	
	public DwgFileV12Reader(boolean isR13){
		r13 = isR13;
		readers.add(null);//0
		readers.add(new LineReader());//1
		readers.add(new PointReader());//2
		readers.add(new CircleReader());//3
		readers.add(new ShapeReader());//4
		readers.add(null);//5
		readers.add(null);//6
		readers.add(new TextReader());//7
		readers.add(new ArcReader());//8
		readers.add(new TraceReader());//9
		readers.add(null);//10
		readers.add(new SolidReader());//11
		readers.add(new BlkReader());//12
		readers.add(new EndBlkReader());//13
		readers.add(new InsertReader());//14
		readers.add(new AttDefReader());//15
		readers.add(new AttribReader());//16
		readers.add(new SbEndReader());//17
		readers.add(null);//18
		readers.add(new PlineReader());//19
		readers.add(new VertexReader());//20
		readers.add(null);//21
		readers.add(new Face3DReader());//22
		readers.add(new DimReader());//23
		readers.add(new VPortReader());//24
	}
	
	

	/* (non-Javadoc)
	 * @see com.iver.cit.jdwglib.dwg.readers.IDwgFileReader#read(com.iver.cit.jdwglib.dwg.DwgFile, java.nio.ByteBuffer)
	 */
	public void read(DwgFile dwgFile, ByteBuffer bb) throws IOException {
		this.dwgFile = dwgFile;
		this.bb = bb;
		try {
////			handle.seek(6, 1) # skip rest of version
//			bb.position(12);
//			bb.position(bb.position() + 6);
			bb.position(0);
			byte[] header = new byte[12];
			bb.get(header);
			String headerStr = new String(header);
			
//		    (_b1, _w1, _w2, _w3, _b2) = struct.unpack("<BhhhB", handle.read(8))
			bb.order(ByteOrder.LITTLE_ENDIAN);
			byte b1 = bb.get();
			short w1 = bb.getShort();
			short w2 = bb.getShort();
			short w3 = bb.getShort();
			byte b2 = bb.get();
			
			
			//To translate Python to Java, we must see the number
			//of bytes of the reading
			
//			 _estart, _eend = struct.unpack("<ll", handle.read(8))
			bb.order(ByteOrder.LITTLE_ENDIAN);
			int eStart = bb.getInt();
			int eEnd = bb.getInt();
			
//			_bsstart, _l1, _bsend, _l2 = struct.unpack("<llll", handle.read(16))
			int bsStart = bb.getInt();
			int l1 = bb.getInt();
			
			int bsEnd = bb.getInt();
			int l2 = bb.getInt();
			
			Dwg12Table blockTable = getTable();
			
			Dwg12Table layerTable = getTable();
			
			Dwg12Table styleTable = getTable();
			
			Dwg12Table lineTypeTable = getTable();
			
			Dwg12Table viewTable = getTable();
			
			readHeader();
			
			Dwg12Table ucsTable = getTable();
			
			bb.position(0x500);
			
			Dwg12Table vportTable = getTable();
			
			bb.position(bb.position() + 8);
			
			Dwg12Table appidTable = getTable();
			
			bb.position(bb.position() + 6);
			
			Dwg12Table dimStyleTable = getTable();
			bb.position(0x69f);
			
			Dwg12Table p13table = getTable();
			
			bb.position(bb.position() + 38);
			
			int currentPosition = bb.position();
			if(currentPosition != eStart){
				//Se supone que deber�amos estar en eStart
				throw new RuntimeException("Error: no se ha llegado al principio de las entidades de dibujo");
			}
			
			//lee primero entidades normales?
			readEntities(eStart, eEnd);
			
			bb.position(bb.position() + 19);
			
			readBlockTable(blockTable);
			readLayerTable(layerTable);
			
//de momento nos saltamos estas tablas
//			readStyleTable(styleTable);
//			readLTypeTable(lineTypeTable);
//			readViewTable(viewTable);
//			readUcsTable(ucsTable);
//			readVportTable(vportTable);
//			readAppidTable(appidTable);
//			readDimStyleTable(dimStyleTable);
//			readP13Table(p13table);
			
			//luego lee entidades de bloque
			readEntities(bsStart, bsEnd);
			
			bb.position(bb.position() + 36);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			
			int peStart, peEnd, pbStart, pbEnd;
			
			peStart = bb.getInt();
			peEnd = bb.getInt();
			pbStart = bb.getInt();
			pbEnd = bb.getInt();
			
			if(peStart != eStart)
				System.out.println("peStart="+peStart+" eStart="+eStart);
			
			if(peEnd != eEnd)
				System.out.println("peStart="+peEnd+" eStart="+eEnd);
			
			if(pbStart != bsStart)
				System.out.println("peStart="+pbStart+" eStart="+bsStart);
			
			if(bsEnd != pbEnd)
				System.out.println("peStart="+pbStart+" eStart="+bsStart);
		   
			bb.position(bb.position() + 12);
			
			Dwg12TableTest bts = getTableTest();
			
			Dwg12TableTest lyrTs = getTableTest();
			
			Dwg12TableTest sts = getTableTest();
			
			Dwg12TableTest ltts = getTableTest();
			
			Dwg12TableTest vts = getTableTest();
			
			Dwg12TableTest uts = getTableTest();
			
			Dwg12TableTest vpts = getTableTest();
			
			Dwg12TableTest ats = getTableTest();
			
			Dwg12TableTest dts = getTableTest();
			
			Dwg12TableTest pts = getTableTest();
			
			
			
			
		} catch (Exception e) {
			e.printStackTrace();
//			logger.error(e);
		}
	}
	
	
	private void readP13Table(Dwg12Table p13table) {
		// TODO Auto-generated method stub
	}



	private void readDimStyleTable(Dwg12Table dimStyleTable) {
		short size = dimStyleTable.s1;
		int numRecs = dimStyleTable.i1;
		int start = dimStyleTable.i2;
		int end = -1;
		bb.position(start);
		for(int i = 0; i < numRecs; i++){
			end = bb.position() + size;
			
			byte flag = bb.get();
			byte[] nameBytes = new byte[32];
			bb.get(nameBytes);
			String name = new String(nameBytes);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short word = bb.getShort();
			
			double[] d4048 = new double[9];
			for(int j = 0; j < 9; j++){
				d4048[j] = bb.getDouble();
			}
			
			double[] d40145 = new double[6];
			for(int j = 0; j < 6; j++){
				d40145[j] = bb.getDouble();
			}
			
			byte[] b7078 = new byte[7];
			for(int j = 0; j < 7; j++){
				b7078[j] = bb.get();
			}
			
			byte[] b170175 = new byte[6];
			for(int j = 0; j < 6; j++){
				b170175[j] = bb.get();
			}
			
			bb.order(ByteOrder.nativeOrder());
			byte[] s3 = new byte[16];
			bb.get(s3);
			
			byte[] s4 = new byte[16];
			bb.get(s4);
			
			byte[] s5 = new byte[32];
			bb.get(s5);
			
			byte[] s6 = new byte[32];
			bb.get(s6);
			
			byte[] s7 = new byte[32];
			bb.get(s6);
			
			bb.position(bb.position() + 3);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short w176 = bb.getShort();
			short w177 = bb.getShort();
			short w178 = bb.getShort();
			
			double d146 = bb.getDouble();
			double d147 = bb.getDouble();
			
			
			int offset = end - bb.position();
			if(offset > 0)
				bb.position(bb.position() + offset);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short crc = bb.getShort();
		}
		byte[] crc32 = new byte[32];
		bb.get(crc32);
	}



	private void readAppidTable(Dwg12Table appidTable) {
		short size = appidTable.s1;
		int numRecs = appidTable.i1;
		int start = appidTable.i2;
		int end = -1;
		bb.position(start);
		for(int i = 0; i < numRecs; i++){
			end = bb.position() + size;
			
			byte flag = bb.get();
			byte[] nameBytes = new byte[32];
			bb.get(nameBytes);
			String name = new String(nameBytes);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short word = bb.getShort();
			
			int offset = end - bb.position();
			if(offset > 0)
				bb.position(bb.position() + offset);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short crc = bb.getShort();
		}
		byte[] crc32 = new byte[32];
		bb.get(crc32);
	}



	private void readVportTable(Dwg12Table vportTable) {
		short size = vportTable.s1;
		int numRecs = vportTable.i1;
		int start = vportTable.i2;
		int end = -1;
		bb.position(start);
		for(int i = 0; i < numRecs; i++){
			end = bb.position() + size;
			
			byte flag = bb.get();
			byte[] nameBytes = new byte[32];
			bb.get(nameBytes);
			String name = new String(nameBytes);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short used = bb.getShort();
			
			double[] pt10 = getPoint(false);
			double[] pt11 = getPoint(false);
			double[] pt17 = getPoint(false);
			double[] pt16 = getPoint(true);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			
			double d50 = bb.getDouble();
			double d40 = bb.getDouble();
			
			double[] pt12 = getPoint(false);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			double d41 = bb.getDouble();
			double d42 = bb.getDouble();
			double d43 = bb.getDouble();
			double d44 = bb.getDouble();
			
			short[] w7178 = new short[8];
			for(int j = 0; j < 8; j++){
				w7178[j] = bb.getShort();
			}
			bb.order(ByteOrder.LITTLE_ENDIAN);
			double d51 = bb.getDouble();
			
			double[] pt13 = getPoint(false);
			double[] pt14 = getPoint(false);
			double[] pt15 = getPoint(false);
			
			int offset = end - bb.position();
			if(offset > 0)
				bb.position(bb.position() + offset);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short crc = bb.getShort();
		}
		byte[] crc32 = new byte[32];
		bb.get(crc32);
	}



	private void readUcsTable(Dwg12Table ucsTable) {
		short size = ucsTable.s1;
		int numRecs = ucsTable.i1;
		int start = ucsTable.i2;
		int end = -1;
		bb.position(start);
		for(int i = 0; i < numRecs; i++){
			end = bb.position() + size;
			
			byte flag = bb.get();
			byte[] nameBytes = new byte[32];
			bb.get(nameBytes);
			String name = new String(nameBytes);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short used = bb.getShort();
			
			double[] pt10 = getPoint(true);
			double[] pt11 = getPoint(true);
			double[] pt12 = getPoint(true);
			
			
			
			int offset = end - bb.position();
			if(offset > 0)
				bb.position(bb.position() + offset);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short crc = bb.getShort();
		}
		byte[] crc32 = new byte[32];
		bb.get(crc32);
		
		
	}



	private void readViewTable(Dwg12Table viewTable) {
		short size = viewTable.s1;
		int numRecs = viewTable.i1;
		int start = viewTable.i2;
		int end = -1;
		bb.position(start);
		for(int i = 0; i < numRecs; i++){
			end = bb.position() + size;
			
			byte flag = bb.get();
			byte[] nameBytes = new byte[32];
			bb.get(nameBytes);
			String name = new String(nameBytes);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short used = bb.getShort();
			double db40 = bb.getDouble();
			
			double[] pt10 = getPoint(false);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			double db41 = bb.getDouble();
			
			double[] pt11 = getPoint(true);
			
			double[] pt12 = getPoint(true);
			
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short w71 = bb.getShort();
			double db42 = bb.getDouble();
			double db43 = bb.getDouble();
			double db44 = bb.getDouble();
			double db50 = bb.getDouble();
			
			int offset = end - bb.position();
			if(offset > 0)
				bb.position(bb.position() + offset);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short crc = bb.getShort();
			
			
		}
		byte[] crc32 = new byte[32];
		bb.get(crc32);
	}



	private void readLTypeTable(Dwg12Table lineTypeTable) {
		short size = lineTypeTable.s1;
		int numRecs = lineTypeTable.i1;
		int start = lineTypeTable.i2;
		int end = -1;
		bb.position(start);
		for(int i = 0; i < numRecs; i++){
			end = bb.position() + size;
			byte flag = bb.get();
			byte[] nameBytes = new byte[32];
			bb.get(nameBytes);
			String name = new String(nameBytes);
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short w1 = bb.getShort();
			
			byte[] s1 = new byte[48];
			bb.get(s1);
			String s1name = new String(s1);
			
			bb.order(ByteOrder.nativeOrder());
			byte b1 = bb.get();
			byte b2 = bb.get();
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			double[] doubles = new double[13];
			for(int j = 0; j < 13; j++){
				doubles[j] = bb.getDouble();
			}
			
			short crc = bb.getShort();
			
			int offset = end - bb.position();
			if(offset > 0)
				bb.position(bb.position() + offset);
		}
		byte[] crc32 = new byte[32];
		bb.get(crc32);
	}



	/**
	 * @param styleTable
	 */
	private void readStyleTable(Dwg12Table styleTable) {
		short size = styleTable.s1;
		int numRecs = styleTable.i1;
		int start = styleTable.i2;
		int end = -1;
		bb.position(start);
		for(int i = 0; i < numRecs; i++){
			end = bb.position() + size;
			byte flag = bb.get();
			byte[] nameBytes = new byte[32];
			bb.get(nameBytes);
			String name = new String(nameBytes);
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short w1 = bb.getShort();
			double d1 = bb.getDouble();
			double d2 = bb.getDouble();
			double d3 = bb.getDouble();
			byte b1 = bb.get();
			double d4 = bb.getDouble();
			
			byte[] s1 = new byte[128];
			bb.get(s1);
			
			short crc = bb.getShort();
			int offset = end - bb.position();
			if(offset > 0)
				bb.position(bb.position() + offset);
		}
		byte[] crc32 = new byte[32];
		bb.get(crc32);
	}



	/**
	 * @param layerTable
	 */
	private void readLayerTable(Dwg12Table layerTable) {
		short size = layerTable.s1;
		int numR = layerTable.i1;
		int start = layerTable.i2;
		
		int begin = -1;
		int end = -1;
		
		DwgLayer layer = null;
		for(int i = 0; i < numR; i++){
			begin = start + i * size;
			bb.position(begin);
			end = begin + size - 2;
			
			layer = new DwgLayer(index);
			index++;
			
			byte flag = bb.get();
			/*
			 +=====================================================+
          | Flag bit | Meaning                                  |
          | value    |                                          |
          |----------|------------------------------------------|
          | 1        | If set, layer is frozen                  |
          |----------|------------------------------------------|
          | 2        | If set, layer is frozen by default in    |
          |          | new Viewports                            |
          |----------|------------------------------------------|
          | 4        | If set, layer is locked                  |
          +-----------------------------------------------------+
			 * */
			if((flag & 0x1) > 0){
				layer.setFrozen(true);
			}
			if((flag & 0x2) > 0){
				layer.setFrozenInNew(true);
			}
			if((flag & 0x4) > 0){
				layer.setLocked(true);
			}
			
			byte[] nameByte = new byte[32];
			bb.get(nameByte);
			String name = new String(nameByte).trim();
			layer.setName(name);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short used = bb.getShort();
			short color = bb.getShort();
			layer.setColor(color);
			short style = bb.getShort();
			short crc = bb.getShort();

			DwgHandleReference handle = new DwgHandleReference(0x5, i);
			layer.setHandle(handle);
			dwgFile.addDwgObject(layer);
			
			
			int offset = end - bb.position();
			if(offset > 0)
				bb.position(bb.position() + offset);
			
		}
		byte[] crc32 = new byte[32];
		bb.get(crc32);
	}


	interface EntityReader{
		void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj);
	}
	
	/**
	 * In DWG 12 version, some kind of objects (Polylines and Vertex) cannot be
	 * instanciated until the EntityReader has readed some stuff (flags and so)
	 * from the file.
	 * 
	 * DefferedEntityReader has the responsability to create DwgObject instances,
	 * and it has the precondition that DwgObject parameter of its method read must
	 * be null.
	 * */
	abstract class DefferedEntityReader implements EntityReader{
		abstract DwgObject getDwgObject(int index);
		
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj){
			if(dwgObj != null)
				throw new RuntimeException("DefferedEntityReader es el encargado de construir los objetos, debe recibirlos a null");
		}
		
	}
	
	class LineReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			if(! (dwgObj instanceof DwgLine))
				throw new RuntimeException("No es entidad LINE");
			DwgLine line = (DwgLine) dwgObj;
			
			boolean zflag = true;
			if( (flags & 0x4) > 0)
				zflag = false;
			
			double[] pt10 = getPoint(zflag);
			double[] pt11 = getPoint(zflag);
			
			line.setP1(pt10);
			line.setP2(pt11);
			
			if((opts & 0x1) > 0){
				double[] pt210 = getPoint(true);
				line.setExtrusion(pt210);
			}
			
			if((opts & 0x2) > 0){
				/*
				 * This field is only found in DWG12 prev
				 * files. Since DWG 12, elevation is saved
				 * in third coordinate of points.
				 * 
				 * */
				bb.order(ByteOrder.LITTLE_ENDIAN);
				double db38 = bb.getDouble();
				line.getP1()[2] = db38;
				line.getP2()[2] = db38;
			}
		}
	}
	
	
	
	class PointReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			if(! (dwgObj instanceof DwgPoint))
				throw new RuntimeException("No es entidad POINT");
			DwgPoint point = (DwgPoint) dwgObj;
			boolean zflag = true;
			if((flags & 0x4) > 0)
				zflag = false;
			double[] pt10 = getPoint(zflag);
			point.setPoint(pt10);
			
			if((opts & 0x1) > 0){
				double[] pt210 = getPoint(true);
				point.setExtrusion(pt210);
			}
			
			if((opts & 0x2) > 0){
				bb.order(ByteOrder.LITTLE_ENDIAN);
				double db38 = bb.getDouble();
				point.getPoint()[2] = db38;
			}
		}
	}
	
	
	class CircleReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			if(! (dwgObj instanceof DwgCircle))
				throw new RuntimeException("No es entidad CIRCLE");
			DwgCircle circle = (DwgCircle) dwgObj;
			
			boolean zflag = true;
			if((flags & 0x4) > 0)
				zflag = false;
			double[] pt10 = getPoint(zflag);
			circle.setCenter(pt10);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			double d40 = bb.getDouble();
			circle.setRadius(d40);
			
			double[] pt210 = null;
			if((opts & 0x1) > 0){
				pt210 = getPoint(true);
				
			}else{
				pt210 = new double[]{0,0,1};
			}
			circle.setExtrusion(pt210);
			if((opts & 0x2) > 0){
				bb.order(ByteOrder.LITTLE_ENDIAN);
				double db38 = bb.getDouble();
				circle.getCenter()[2] = db38;
			}
		}
	}
	
	
	
	class ShapeReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			
			//TODO POR IMPLEMENTAR DwgShape (referencia a un
			//fichero de texto)
			
			double[] pt10 = getPoint(false);
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short w2 = bb.getShort();
			if((opts & 0x1) > 0){
				double[] pt210 = getPoint(true);
			}
			if((opts & 0x2) > 0){
				bb.order(ByteOrder.LITTLE_ENDIAN);
				double db38 = bb.getDouble();
			}
		}
	}
	
	public String getString(){
		bb.order(ByteOrder.LITTLE_ENDIAN);
		short len = bb.getShort();
		byte[] bytes = new byte[len];
		bb.order(ByteOrder.nativeOrder());
		bb.get(bytes);
		return new String(bytes);
	}
	
	
	class TextReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			
			if(! (dwgObj instanceof DwgText))
				throw new RuntimeException("No es entidad TEXT");
			DwgText txt = (DwgText) dwgObj;
			
			
			double[] pt10 = getPoint(false);
			txt.setInsertionPoint(new Point2D.Double(pt10[0], pt10[1]));
			
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			double db40 = bb.getDouble();
			txt.setHeight(db40);
			
			
			
			String text = getString();
			txt.setText(text);
			if((opts & 0x1) > 0){
				bb.order(ByteOrder.LITTLE_ENDIAN);
				double db50 = bb.getDouble();
				txt.setRotationAngle(db50);
			}
			if((opts & 0x2) > 0){
				double db41 = bb.getDouble();
				txt.setWidthFactor(db41);//TODO 41 es width factor seguro?
			}
			if((opts & 0x4) > 0){
				double db51 = bb.getDouble();
				txt.setObliqueAngle(db51);
			}
			if((opts & 0x8) > 0){
				byte b7 = bb.get();
			}
			if((opts & 0x10) > 0){
				byte b71 = bb.get();
				//parametros de mirroring
				txt.setGeneration(b71);
			}
			if((opts & 0x20) > 0){
				byte b72 = bb.get();
				txt.setHalign(b72);
			}
			if((opts & 0x40) > 0){
				double[] pt11 = getPoint(false);
				txt.setAlignmentPoint(new Point2D.Double(pt11[0], pt11[1]));
			}
			if((opts & 0x100) > 0){
				byte b73 = bb.get();
				txt.setValign(b73);
			}
			
			//TODO La especificaci�n DXF 12 dice que la extrusion 
			//codigos DXF 210, 220, 230 se aplica sobre:
			/*
			 Line, Point, Circle, Shape, Text, Arc, Trace,
			 Solid, Block Reference, Polyline, 
			  Dimension, Attribute, and Attribute Definition entity
			  
			  Pero aqu� no aparece por ningun lado la extrusion
			 * */
			double[] ext = new double[]{0, 0, 1};
			txt.setExtrusion(ext);
		}
	}
	
	
	class ArcReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			if(! (dwgObj instanceof DwgArc))
				throw new RuntimeException("No es entidad ARC");
			DwgArc arc = (DwgArc) dwgObj;
			
			double[] pt10 = getPoint(false);
			arc.setCenter(pt10);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			double d40 = bb.getDouble();
			arc.setRadius(d40);
			
			double d50 = bb.getDouble();
			arc.setInitAngle(d50);
			
			double d51 = bb.getDouble();
			arc.setEndAngle(51);
			
			double[] pt210 = null;
			if((opts & 0x1) > 0){
				pt210 = getPoint(true);
				arc.setExtrusion(pt210);
			}else{
				pt210 = new double[]{1, 0, 0};
			}
			if((opts & 0x2) > 0){
				bb.order(ByteOrder.LITTLE_ENDIAN);
				double db38 = bb.getDouble();
				arc.getCenter()[2] = db38;
			}
		}
	}
	
	
	
	class TraceReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			//TODO Implementar DwgTrace
			double[] pt10 = getPoint(false);
			double[] pt11 = getPoint(false);
			double[] pt12 = getPoint(false);
			double[] pt13 = getPoint(false);
			if((opts & 0x1) > 0){
				double[] pt210 = getPoint(true);
			}
			if((opts & 0x2) > 0){
				bb.order(ByteOrder.LITTLE_ENDIAN);
				double db38 = bb.getDouble();
			}
		}
	}
	
	class SolidReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			if(! (dwgObj instanceof DwgSolid))
				throw new RuntimeException("No es entidad SOLID");
			DwgSolid solid = (DwgSolid) dwgObj;
			
			
			
			double[] pt11 = getPoint(false);
			solid.setCorner1(pt11);
			
			double[] pt12 = getPoint(false);
			solid.setCorner2(pt12);
			
			double[] pt13 = getPoint(false);
			solid.setCorner3(pt13);
			
			double[] pt14 = getPoint(false);
			solid.setCorner4(pt14);
			
			
			if((opts & 0x1) > 0){
				double[] pt210 = getPoint(true);
				solid.setExtrusion(pt210);
			}
			if((opts & 0x2) > 0){
				bb.order(ByteOrder.LITTLE_ENDIAN);
				double db38 = bb.getDouble();
				solid.getCorner1()[2] = db38;
				solid.getCorner2()[2] = db38;
				solid.getCorner3()[2] = db38;
				solid.getCorner4()[2] = db38;
			}
			
			solid.setExtrusion(new double[]{0, 0, 1});
		}
	}
	
	
	private Block getBlock(String blockName){
		for(int i = 0; i < blocks.size(); i++){
			Block block = (Block) blocks.get(i);
			if(block.name.equalsIgnoreCase(blockName)){
				return block;
			}
		}
		return null;
	}
	
	
	
	class BlkReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			if(! (dwgObj instanceof DwgBlockHeader))
				throw new RuntimeException("No es entidad BLOCK");
			DwgBlockHeader blk = (DwgBlockHeader) dwgObj;
			
			
			double[] pt10 = getPoint(false);
			blk.setBasePoint(pt10);
			String blockName = getString();
			blk.setName(blockName);
			Block block = getBlock(blockName);
			if(block == null){
				System.out.println(blockName+" no encontrado en la tabla de bloques");
			}
			
			if((opts & 0x2) > 0)
			{
				//puede ser que se trate de referencias
				//externas??
				String s3 = getString();
			}
			
			if((flags & 1) > 0){
				blk.setAnonymous(true);
			}
			
			if((flags & 2) > 0){
				blk.setHasAttrs(true);
			}
			
			if((flags & 4) > 0){
				blk.setBlkIsXRef(true);
			}
			
			if((flags & 16) > 0){
				blk.setXdep(true);
			}
			
			if((flags & 32) > 0){
				blk.setXRefOverLaid(true);
			}
			
			if((flags & 64) > 0){
				blk.setLoaded(true);
			}
			
			
			/*
			
			   1        | This is an anonymous Block generated by    |
	          |          | hatching, associative dimensioning, other  |
	          |          | internal operations, or an application     |
	          |----------|--------------------------------------------|
	          | 2        | This Block has Attributes                  |
	          |----------|--------------------------------------------|
	          | 4        | This Block is an external reference (Xref) |
	          |----------|--------------------------------------------|
	          | 8        | not used                                   |
	          |----------|--------------------------------------------|
	          | 16       | This Block is externally dependent         |
	          |----------|--------------------------------------------|
	          | 32       | This is a resolved external reference, or  |
	          |          | dependent of an external reference         |
	          |----------|--------------------------------------------|
	          | 64       | This definition is referenced       
			
			*/
		
		}
	}
	class EndBlkReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
		}
	}
	
	class InsertReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			if(! (dwgObj instanceof DwgInsert))
				throw new RuntimeException("No es entidad INSERT");
			DwgInsert insert = (DwgInsert) dwgObj;
			
			bb.order(ByteOrder.nativeOrder());
			short w1 = bb.getShort();//Puede ser este el identificador de bloque???
			
			DwgHandleReference blockHandle = new 
				DwgHandleReference(0x5, w1);
			insert.setBlockHeaderHandle(blockHandle);
			
			double[] pt10 = getPoint(false);
			insert.setInsertionPoint(pt10);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			
			double x = 0d, y = 0d, z = 0d;
			
			if((opts & 0x1) > 0){
				double db41 = bb.getDouble();
				x = db41;
			}
			
			if((opts & 0x2) > 0){
				double db42 = bb.getDouble();
				y = db42;
			}
			
			if((opts & 0x4) > 0){
				double db43 = bb.getDouble();
				z = db43;
			}
			
			insert.setScale(new double[]{x, y, z});
			
			if((opts & 0x8) > 0){
				double db50 = bb.getDouble();
				insert.setRotation(db50);
			}
			
			if((opts & 0x10) > 0){
				short w70 = bb.getShort();
				//column counts
			}
			//creo que esto est� mal, y que debe poner 0x20
			if((opts & 0x10) > 0){
				short w71 = bb.getShort();
				//row counts
			}
			
			if((opts & 0x40) > 0){
				double db44 = bb.getDouble();
				//column spacing
			}
			
			if((opts & 0x80) > 0){
				double db45 = bb.getDouble();
				//row spacing
			}
			insert.setExtrusion(new double[]{0, 0, 1});
		}
	}
	
	class AttDefReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			double[] p10 = getPoint(false);
			String s1 = getString();
			String s3 = getString();
			String s2 = getString();
			bb.order(ByteOrder.LITTLE_ENDIAN);
			byte b70 = bb.get();
			
			if((opts & 0x1) > 0){
				byte b73 = bb.get();
			}
			
			if((opts & 0x2) > 0){
				double d50 = bb.getDouble();
			}
			
			if((opts & 0x4) > 0){
				double d41 = bb.getDouble();
			}
			
			if((opts & 0x8) > 0){
				double d42 = bb.getDouble();
			}
			
			if((opts & 0x10) > 0){
				byte b7 = bb.get();
			}
			
			if((opts & 0x20) > 0){
				byte b71 = bb.get();
			}
			
			if((opts & 0x40) > 0){
				byte b72 = bb.get();
			}
			
			if((opts & 0x80) > 0){
				double[] p11 = getPoint(false);
			}
			
			if((opts & 0x100) > 0){
				double[] p210 = getPoint(true);
			}
			
			if((opts & 0x200) > 0){
				bb.order(ByteOrder.LITTLE_ENDIAN);
				double d38 = bb.getDouble();
			}
		}
	}
	
	class AttribReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			double[] p10 = getPoint(false);
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			double d40 = bb.getDouble();
			
			String s1 = getString();
			String s2 = getString();
			
			if((opts & 0x1) > 0){
				byte b73 = bb.get();
			}
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			if((opts & 0x2) > 0){
				double d50 = bb.getDouble();	
			}
			
			if((opts & 0x4) > 0){
				double d41 = bb.getDouble();	
			}
			
			if((opts & 0x8) > 0){
				double d42 = bb.getDouble();	
			}
			
			if((opts & 0x10) > 0){
				byte b7 = bb.get();
			}
			
			if((opts & 0x20) > 0){
				byte b71 = bb.get();
			}
			
			if((opts & 0x40) > 0){
				byte b72 = bb.get();
			}
			
			if((opts & 0x80) > 0){
				double[] p11 = getPoint(false);
			}
			double[] p210 = null;
			if((opts & 0x100) > 0){
				p210 = getPoint(true);
			}else{
				p210 = new double[]{0, 0, 1};
			}
			bb.order(ByteOrder.LITTLE_ENDIAN);
			if((opts & 0x200) > 0){
				double d38 = bb.getDouble();
			}
		}
	}
	
	
	class SbEndReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			bb.order(ByteOrder.LITTLE_ENDIAN);
			int l = bb.getInt();
		}
	}
	
	class PlineReader extends DefferedEntityReader{
		
		/*
		 * CURVE TYPE CONSTANTS
		 * */
		final static int CLOSED       = 0x01;//if line is a mesh, curve closed in M direction
		final static int CURVE_FIT    = 0x02;
		final static int SPLINE_FIT     = 0x04;
		final static int PLINE3D    = 0x08;
		final static int MESH          = 0x10;
		final static int MESH_CLOSED   = 0x20;//curve closed in N direction
		final static int ANY_MESH = 0x30;  //MESH | MESH_CLOSED
		final static int PFACE          = 0x40;
		final static int CONT_LTYPE   = 0x80;
		
		/*
		 * polyline attributes
		 * */
		/**
		 * flag: curve type (CLOSED, MESH,PFACE, etc.)
		 * */
		byte flag70;
		/**
		 * Number of points in M direction for a Mesh,
		 * number of vertices for a PFace polyline
		 * */
		byte meshM71;
		/**
		 * Number of points in N direction for a Mesh,
		 * number of faces for a PFace polyline
		 * */
		byte meshN72;
		double startW40;
		byte smoothM73;
		byte smoothN74;
		byte curveType75;
		
		
		private void reset(){
			flag70 = 0;
			meshM71 = 0;
			meshN72 = 0;
			startW40 = 0;
			smoothM73 = 0;
			smoothN74 = 0;
			curveType75 = 0;
		}
		
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			super.read(bb, flags, opts, dwgObj);
			
			//TODO El byte 70 es el que determina el tipo de Polyline
			if( (opts & 0x1) > 0){
				flag70 = bb.get();
			}
			bb.order(ByteOrder.LITTLE_ENDIAN);
			if( (opts & 0x2) > 0){
				startW40 = bb.getDouble();
			}
			
			if( (opts & 0x4) > 0){
				meshM71 = bb.get();
			}
			
			if( (opts & 0x8) > 0){
				meshN72 = bb.get();
			}
			
			if( (opts & 0x10) > 0){
				smoothM73 = bb.get();
			}
			
			if( (opts & 0x20) > 0){
				smoothN74 = bb.get();
			}
			
			if( (opts & 0x40) > 0){
				curveType75 = bb.get();
			}
		}

		DwgObject getDwgObject(int index) {
			DwgObject solution = null;
			boolean isSpline = (flag70 & SPLINE_FIT) != 0 ? true: false;
			if( (flag70 & PFACE) != 0){
				//PFacePolyline
				solution = new DwgPFacePolyline(index);
//	often made wrong, so we have to correct...TODO Revisar
				if(meshM71 <= 0)
					meshM71 = 16;
				if(meshN72 <= 0)
					meshN72 = 4;
				((DwgPFacePolyline)solution).setVertexCount(meshM71);
				((DwgPFacePolyline)solution).setFaceCount(meshN72);
			}else if((flag70 & ANY_MESH) != 0){
				//Mesh, closed or not
				solution = new DwgMeshPolyline(index);
				boolean isClosedM = (flag70 & CLOSED) != 0 ? true: false;
				boolean isClosedN = (flag70 & MESH_CLOSED) > 0 ? true: false;
				
				((DwgMeshPolyline)solution).setClosedM(isClosedM);
				((DwgMeshPolyline)solution).setClosedN(isClosedN);
				if(isSpline){
					((DwgMeshPolyline)solution).setMVerticies(smoothM73);
					((DwgMeshPolyline)solution).setNVerticies(smoothN74);
				}else{
					((DwgMeshPolyline)solution).setMVerticies(meshM71);
					((DwgMeshPolyline)solution).setNVerticies(meshN72);
				}
				((DwgMeshPolyline)solution).setCurveType(curveType75);
			}else{
				//polyline
				boolean is3DPolyline = (flag70 & PLINE3D) != 0 ? true: false;
				if(is3DPolyline)
				{
					solution = new DwgPolyline3D(index);
					boolean isClosed = (flag70 & CLOSED) != 0 ? true: false;
					//for compatibility with dwg 13 and later, we use a byte flag for
					//closed and spline properties
					((DwgPolyline3D)solution).setClosedFlags(isClosed ? 0x1: 0x0);
					((DwgPolyline3D)solution).setSplineFlags(isSpline ? 0x1: 0x0);
					
				}else{
					solution = new DwgPolyline2D(index);
					((DwgPolyline2D)solution).setCurveType(curveType75);
					((DwgPolyline2D)solution).setInitWidth(startW40);
				}
			}
			
			reset();
			
			return solution;
		}
	}
	
	class VertexReader extends DefferedEntityReader{
		final static int FIT_POINT    = 0x01;
		final static int TANGENT      = 0x02;
		final static int SPLINE_LINE_FIT     = 0x08;
	    final static int SPLINE_CONTROL_POINT      = 0x10;
	    final static int POLYLINE_3D      = 0x20;
		final static int MESH_3D       = 0x40;
		final static int PFACE_MESH  = 0x80;
		
		/**
		 * Coordinates of the vertex
		 * */
		double[] pt10;
		
		/**
		 * Start width of the vertex. If 0, it will
		 * use the start with of the owner polyline.
		 * */
		double startWidth40;
		/**
		 * End width of the vertex. If 0, it will
		 * use the end with of the owner polyline.
		 * */
		double endWidth41;
		
		/**
		 * Bulge of the vertex
		 * */
		double tangentDir50;
		
		/**
		 * Flag that maks what kind of vertex is:
          1        | Extra vertex created by curve-fitting       |
          2        | Curve-fit tangent defined for this vertex.  |
          |          | A curve-fit tangent direction of 0 may be   |
          |          | omitted from the DXF output, but is         |
          |          | significant if this bit is set              |
          |----------|---------------------------------------------|
          | 4        | Unused (never set in DXF files)             |
          |----------|---------------------------------------------|
          | 8        | Spline vertex created by spline-fitting     |
          |----------|---------------------------------------------|
          | 16       | Spline frame control point                  |
          |----------|---------------------------------------------|
          | 32       | 3D Polyline vertex                          |
          |----------|---------------------------------------------|
          | 64       | 3D polygon mesh vertex                      |
          |----------|---------------------------------------------|
          | 128      | Polyface mesh vertex                        |
          +--------------------------------------------------------+
		 * */
		byte vertexFlag70;
		
		/**
		 * If the vertex is a pfaceface vertex it hasnt real coordinates.
		 * Instead it has an index for each vertex of the mesh's face
		 * */
		int[] pfacefaceIndex;
		
		void reset(){
			pt10 = null;
			startWidth40 = 0;
			endWidth41 = 0;
			tangentDir50 = 0;
			vertexFlag70 = 0;
			pfacefaceIndex = null;
		
		}
		
		/*
		 * azabala
		 * Nos estabamos encontrando con vertices muy raros
		 * (e incluso con valores NaN) cuando el valor de opts
		 * es 16872, si seguiamos al pie de la letra la especificaci�n
		 * de http://www.iwriteiam.nl/DWG12.html o Pythoncad.
		 * 
		 * Haciendo un poco de ingenieria inversa hemos visto que
		 * si opts==16872, hay que modificar el algoritmo 
		 * */
		
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			super.read(bb, flags, opts, dwgObj);
			if(opts != 16872){
				int position = bb.position();
				pt10 = getPoint(false);
if(pt10[0] < 0 || pt10[0] < 600000 || pt10[0] > 800000){
System.currentTimeMillis();
}
				bb.order(ByteOrder.LITTLE_ENDIAN);
				if((opts & 0x1) > 0){
					startWidth40 = bb.getDouble();
				}
				if((opts & 0x2) > 0){
					endWidth41 = bb.getDouble();
				}
				if((opts & 0x4) > 0){
					tangentDir50 = bb.getDouble();
				}
				if((opts & 0x8) > 0){
					vertexFlag70 = bb.get();
				}
			}else{
				//if opts == 16872 (decimal) we invert the
				//order of the reading
				bb.order(ByteOrder.LITTLE_ENDIAN);
				if((opts & 0x1) > 0){
					startWidth40 = bb.getDouble();
				}
				if((opts & 0x2) > 0){
					endWidth41 = bb.getDouble();
				}
				if((opts & 0x4) > 0){
					tangentDir50 = bb.getDouble();
				}
				if((opts & 0x8) > 0){
					vertexFlag70 = bb.get();
				}
				int p1 = bb.getShort();
				int p2 = bb.getShort();
				int p3 = bb.getShort();
				int p4 = bb.getShort();
				
				pfacefaceIndex = new int[]{p1,p2,p3,p4};
			}
			
			
			
		}

		DwgObject getDwgObject(int index) {
			DwgObject solution = null;
			if( (vertexFlag70 & PFACE_MESH) != 0){
				//It is a PFace Mesh Vertex
				if( (vertexFlag70 & MESH_3D) != 0){
					solution = new DwgVertexPFace(index);
					((DwgVertexPFace)solution).setPoint(pt10);
					((DwgVertexPFace)solution).setFlags(vertexFlag70);
				}else{
					/*
					azabala
					 DXF 12 spec says:
					 	"If the Vertex defines a face of the mesh, 
					 	its Vertex flags (70) group has the 128 bit 
					 	set but not the 64 bit. The 10, 
					 	20, and 30 (location) groups of the face entity are 
					 	irrelevant and are always written as zero in a DXF file. 
					 	The vertex indexes that define the mesh are given by 71, 
					 	72, 73, and 74 groups, the values of which are integers 
					 	specifying one of the previously defined vertices by 
					 	index. 
					 	If the index is negative, the edge that begins with 
					 	that vertex is invisible. 
					 	
					 	The first zero vertex marks the 
					 	end of the vertices of the face. 
					 	
					 	Since the 71 through 74 
					 	groups are optional fields with default values of zero, 
					 	they are present in DXF only if nonzero."
					 	
					 But DWG 12 spec doesnt say anything about 71,72,73 and
					 74 fields for VERTEX.	
					 * */
					solution = new DwgVertexPFaceFace(index);
					((DwgVertexPFaceFace)solution).setVerticesidx(pfacefaceIndex);
				}
			}else if( (vertexFlag70 & POLYLINE_3D) != 0){
				solution = new DwgVertex3D(index);
				((DwgVertex3D)solution).setPoint(pt10);
				((DwgVertex3D)solution).setFlags(vertexFlag70);
			}else{
				solution = new DwgVertex2D(index);
				((DwgVertex2D)solution).setPoint(pt10);
				((DwgVertex2D)solution).setFlags(vertexFlag70);
			}
			
			reset();
			return solution;
		}
	}
	
	class Face3DReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			boolean zflag = false;
			if((flags & 0x4) > 0){
				zflag = true;
			}
			double[] pt10 = getPoint(zflag);
			double[] pt11 = getPoint(zflag);
			double[] pt12 = getPoint(zflag);
			double[] pt13 = getPoint(zflag);
		
		}
	}
	
	class DimReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			bb.order(ByteOrder.LITTLE_ENDIAN);
			short w1 = bb.getShort();
			double[] pt10 = getPoint(true);
			double[] pt11 = getPoint(false);
			
			if((opts & 0x2) > 0){
				byte b70 = bb.get();
			}
			
			if((opts & 0x1) > 0){
				double[] pt12 = getPoint(true);
			}
			
			if((opts & 0x4) > 0){
				String s1 = getString();
			}
			
			if((opts & 0x8) > 0){
				double[] pt13 = getPoint(true);
			}
			
			if((opts & 0x10) > 0){
				double[] pt13 = getPoint(true);
			}
			
			if((opts & 0x20) > 0){
				double[] pt15 = getPoint(true);
			}
			
			if((opts & 0x40) > 0){
				double[] pt16 = getPoint(true);
			}
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			if((opts & 0x80) > 0){
				double d40 = bb.getDouble();
			}
			
			if((opts & 0x100) > 0){
				double d50 = bb.getDouble();
			}
			
			if((opts & 0x200) > 0){
				double d51 = bb.getDouble();
			}
			if((opts & 0x400) > 0){
				double d52 = bb.getDouble();
			}
			if((opts & 0x800) > 0){
				double d53 = bb.getDouble();
			}
		}
	}
	
	class VPortReader implements EntityReader{
		public void read(ByteBuffer bb, byte flags, short opts, DwgObject dwgObj) {
			double[] pt10 = getPoint(true);
			bb.order(ByteOrder.LITTLE_ENDIAN);
			double d40 = bb.getDouble();
			double d41 = bb.getDouble();
			short w68 = bb.getShort();
		}
	}
	
	/**
	 * @param start
	 * @param end
	 */
	private void readEntities(int start, int end) {
		bb.position(start);
		int ant = bb.position();
		int emax = readers.size();
		EntityReader reader = null;
		
		/*
		 * it isnt null until well finish to read the vertices
		 * of a given polyline (seqend found)
		 * 
		 */
		IDwgPolyline currentPolyline = null;
		
		/*
		 * Not null when a DwgBlock is found, it will be null
		 * when a DwgEndBlk found. While this, all entities readed
		 * will be added to currentBlock
		 * */
		DwgBlockHeader currentBlock = null;
		
		while(ant < (end - 32)){
			bb.order(ByteOrder.LITTLE_ENDIAN);
			
			byte kind = bb.get();
			if(kind < emax){
				reader = (EntityReader) readers.get(kind);
			}//if
			
			
			//PROPERTIES COMMON TO ALL DWG 12 ENTITIES
			byte flag = bb.get();
			short lenght = bb.getShort();
			
			//segun esto los dos ultimos bytes son el CRC
			int crcpos = ant + (lenght - 2);
			
			
			short layer = bb.getShort();
			short opts = bb.getShort();
			
			byte color = 0;
			if ((flag & 0x1) > 0){
				color = bb.get();
			}
			
			byte extra = 0;
			if ((flag & 0x40) > 0)
				extra = bb.get();
			
			
			String xdata = null;
			if((extra & 0x2) > 0)
				xdata = readXdata();
			
			
			short type = 0;
			if((flag & 0x2) > 0)
				type = bb.getShort();
			
			
			double z = 0d;
			if( (flag & 0x4) > 0 && (kind > 2) && (kind != 22)){
				z = bb.getDouble();
			}
			
			double th = 0d;
			if((flag & 0x8) > 0){
				th = bb.getDouble();
			}
			
			byte[] handle = null;
			if((flag & 0x20) > 0)
				handle = getHandle();
			
			short paper = 0;
			if((extra & 0x4) > 0){
				paper = bb.getShort();
			}
			
			if(reader != null){
				DwgObject entity = null;
				
				entity = DwgObjectFactory.
							getInstance().
							create(kind, index);
				
				//TODO Idem con el espacio papel o el espacio modelo
				boolean paperSpace = false;
				if(paper != 0){
					paperSpace = true;
				}
				reader.read(bb, flag, opts, entity);
				if(reader instanceof DefferedEntityReader){
					entity = ((DefferedEntityReader)reader).getDwgObject(index);	
				}
				
				if(entity instanceof IDwgPolyline){
					currentPolyline = (IDwgPolyline) entity;
				}
				else if(entity instanceof DwgSeqend){
					currentPolyline = null;
				}else if(entity instanceof DwgBlockHeader){
					currentBlock = (DwgBlockHeader) entity;
				}else if(entity instanceof DwgEndblk){
					currentBlock = null;
				}
				
				DwgHandleReference hdl = null;
				/*
				In V12 format a handle has 2 bytes, while
				in later formats a hande has 4 bytes. To avoid
				rewriting a lot of code we are going to do some "tricks"
				with handles.
				*/
				if(entity instanceof DwgBlockHeader){
					/*
					 * If entity is a block, in a later step we'll match
					 * an insert with its block by handle.
				     * In dwg 12 format, association insert-blocks is not
				     * by handle (is from the order of the block in block table)
				     * So here we use a little trick to avoid rewriting of
				     * block and inserts management logic.
					 * */
					int order = -1;
					DwgBlockHeader blk = (DwgBlockHeader) entity;
					String blockName = blk.getName();
					Block block = getBlock(blockName);
					if(block != null){
						order = blocks.indexOf(block);
						hdl = new DwgHandleReference(0, order);
					}else{
						System.out.println("BLOQUE "+blockName+" NO EST� EN LA TABLA DE BLOQUES");
						bb.position(crcpos);
						short crc = bb.getShort();
						continue;
					}
				}else{
					if(handle != null){
						int offset = handle.hashCode();
						hdl = new DwgHandleReference(0, offset);
					}else{
						System.out.println("HANDLE A NULL");
						bb.position(crcpos);
						short crc = bb.getShort();
						continue;
					}
				}
				
				entity.setColor(color);
				entity.setType(type);//TODO Este type es el mismo que para DWG 13-14-2000?
				entity.setSizeInBits(lenght);//TODO Este size es el mismo que para DWG 13-14-2000?
				entity.setHandle(hdl);
				/*
				 * TODO
				 * Parece ser que DWG 12 no gestiona las layers al igual que las
				 * versiones sucesivas (hay que descifrar si 'layer' significa
				 * un orden en la tabla de layers
				 * 
				 * De ser as�, y si indexamos las layers de esta forma
				 * (con un HandleReference de code 0x5) ser� todo homogeneo
				 * 
				 * TODO Construir instancias de DwgLayer a partir de las entradas
				 * de la tabla de layers, e indexarlas con un handle igual a su orden
				 * */
				
				entity.setLayerHandle(new DwgHandleReference(0x5, layer));
				
				//TODO El valor de elevation en 12 es comun a todas, en 13 y ulteriores
				//no. ver que se hace
//				entity.setZ(z);
				
				List xdataAsList = new ArrayList();
				xdataAsList.add(xdata);
				entity.setExtendedData(xdataAsList);
				
				//TODO con thickness tenemos el mismo problema que con
				//elevation. En dwg 12 es comun a todos
//				entity.setThickness(th);
				
				ant = bb.position();
//				if(ant < crcpos){
				if(ant != crcpos){
					bb.position(bb.position() + (crcpos - ant));
				}
				short crc = bb.getShort();
				
				if( (entity instanceof IDwgVertex) && (currentPolyline != null)){
					currentPolyline.addVertex((IDwgVertex) entity);
					
				}else if( (entity instanceof IDwgBlockMember) && 
						!(entity instanceof IDwgVertex) &&
						(currentBlock != null)){
					//In DWG 12 vertex is not part of Block.
					//its part of a polyline (which is part of a block)
					currentBlock.addObject(entity);
				} else{
//					if(! paperSpace)//TODO solo a�adimos las entidades en espacio modelo????
					dwgFile.addDwgObject(entity);
				}
			}//if reader
			else{
				System.out.println("Reader a NULL. DWG 12 MAL LEIDO");
				System.out.println("kind = " + kind);
				bb.position(crcpos);
				short crc = bb.getShort();
				continue;
				
			}
			ant = bb.position();
//			byte[] crc32 = new byte[32];
//			bb.get(crc32);
			index++;
		}//while
		byte[] crc32 = new byte[32];//TODO va dentro o fuera del while??
		bb.get(crc32);
	}


	/**
	 * @return
	 */
	private byte[] getHandle() {
		 byte[] bytes = null;
		 bb.order(ByteOrder.nativeOrder());
		 byte len = bb.get();
		 bytes = new byte[len];
		 bb.get(bytes);
		 return bytes;
//Ver si los handles de DWG 12 concurdan con nuestra clase
//DwgHandleReference
//	     return (5, _len) + tuple(_bytes)
	}



	/**
	 * @return
	 */
	private String readXdata() {
		String extData = "";
		short xlen = bb.getShort();
		while (xlen > 0){
			byte xval = bb.get();
			xlen--;
			if(xval == 0){
				if(xlen < 1)
					break;
				byte val = bb.get();
				xlen--;
				if(r13){
					if(xlen < 1)
						break;
					byte codePage = bb.get();
					xlen--;
				}//if r13
				if(xlen < val)
					break;
				byte[] strByte = new byte[val];
				bb.get(strByte);
				xlen -= val;
				extData += new String(strByte);
			}//if xval == 0
			else if(xval == 1 || xval == 3 || xval == 70){
				if(xlen < 2)
					break;
				short val = bb.getShort();
				extData += val;
				xlen += 2;
			}else if(xval == 2){
				if(xlen < 1)
					break;
				byte val = bb.get();
				if(val == 0)
					extData += "{";
				else if(val == 1)
					extData += "}";
				else
					System.out.println("Byte no esperado:"+val);
			}else if(xval == 5){
				if(xlen < 8)
					break;
				long val = bb.getLong();
				//probably it is an entity handle
				xlen -= 8;
			}else if (xval == 40 || xval == 41 || xval == 42){
				if (xlen < 8)
					break;
				double val = bb.getDouble();
				xlen -= 8;
				extData += val;
				
			}else if (xval == 10 || xval == 11 || xval == 12 || xval == 13){
				//13 not in R12 spec, is in R13/R14
				if(xlen < 24)
					break;
				Object point = getPoint(true);
				extData += point.toString();
				xlen -= 24;
			}else if(xval == 71){
				if (xlen < 4)
					break;
				int val = bb.getInt();
				extData += val;
				xlen -= 4;
			}else
				xlen = 0;
			return extData;
		}
		/*

           
       
        elif _xval == 71:
            if _xlen < 4: break
            _val = struct.unpack('<l', handle.read(4))[0]
            _data.append(_val)
            _xlen = _xlen - 4
        else:
            _xlen = 0
    return _data
		 * */
		return null;
	}



	/**
	 * @param b
	 * @return
	 */
	private double[] getPoint(boolean b) {
		bb.order(ByteOrder.LITTLE_ENDIAN);
		double x = bb.getDouble();
		double y = bb.getDouble();
		double z = 0d;
		if(b){
			z = bb.getDouble();
		}
		return new double[]{x, y, z};
	}



	//TODO Que se hacen con los registros que se leen???
	private void readBlockTable(Dwg12Table blockTable) {
		short size = blockTable.s1;
		int numRecords =  blockTable.i1;
		int start = blockTable.i2;
		
		int begin = -1;
		int end = -1;
		
		for(int i = 0; i < numRecords; i++){
			
			begin = start + i * size;
			bb.position(begin);
			
			end = begin + size - 2;
	
			byte flag = bb.get();
			byte[] nameByte = new byte[32];
			bb.get(nameByte);
			String name = new String(nameByte).trim();
			
			bb.order(ByteOrder.LITTLE_ENDIAN);
			
			short used = bb.getShort();
			byte b1 = bb.get();
			short w1 = bb.getShort();
			byte b2 = bb.get();
			
			short w3 = bb.getShort();
			short crc = bb.getShort();
		
			int offset = end - bb.position();
			if(offset > 0)
				bb.position(bb.position() + end);
			
			Block block = new Block();
			block.flag = flag;
			block.name = name;
			block.used = used;
			block.b1 = b1;
			block.w1 = w1;
			block.b2 = b2;
			block.w3 = w3;
			block.crc = crc;
			blocks.add(block);
		}//for
		byte[] crc32 = new byte[32];
		bb.get(crc32);
	}

	public void readHeader(){
		bb.order(ByteOrder.LITTLE_ENDIAN);
		short w1 = bb.getShort();
		double[] inBase = getPoint(true);
		double[] extMin = getPoint(true);
		dwgFile.setHeader("MSPACE_EXTMIN", extMin);
		double[] extMax = getPoint(true);
		dwgFile.setHeader("MSPACE_EXTMAX", extMax);
		double[] limMin = getPoint(false);
		double[] limMax = getPoint(false);
		
		bb.order(ByteOrder.LITTLE_ENDIAN);
		double vcx = bb.getDouble();
		double vcy = bb.getDouble();
		double d3 = bb.getDouble();
		double d4 = bb.getDouble();
		
		byte b1 = bb.get();
		byte b2 = bb.get();
		
		double sx = bb.getDouble();
		double sy = bb.getDouble();
		
		bb.order(ByteOrder.nativeOrder());
		byte[] b56 = new byte[56];
		bb.get(b56);
		
		bb.order(ByteOrder.LITTLE_ENDIAN);
		double d7 = bb.getDouble();
		double d8 = bb.getDouble();
		double d9 = bb.getDouble();
		
		bb.order(ByteOrder.nativeOrder());
		byte[] b18 = new byte[18];
		bb.get(b18);
		
		bb.order(ByteOrder.LITTLE_ENDIAN);
		double d10 = bb.getDouble();
		
		int at = bb.position();
		
		bb.order(ByteOrder.LITTLE_ENDIAN);
		short w2 = bb.getShort();
		short w3 = bb.getShort();
		
		bb.order(ByteOrder.nativeOrder());
		byte[] b44 = new byte[44];
		bb.get(b44);
		
		at = bb.position();
		
		bb.order(ByteOrder.nativeOrder());
		byte[] b354 = new byte[354];
		bb.get(b354);
		
		if( (b354[0] == 0x61) && (b354[1] == 0x63) && (b354[2] == 0x61 ) && (b354[2] == 0x64 ))
			System.out.println("Encontrada la cadena 'acad' al comienzo del bloque de 354 bytes");
	
		bb.position(0x3ef);
	}
	
	class Dwg12Table{
		short s1;
		int i1;
		int i2;
	}
	
	public Dwg12Table getTable(){
		
		Dwg12Table solution = null;
		bb.order(ByteOrder.LITTLE_ENDIAN);
		
		short s1 = bb.getShort();
		int i1 = bb.getInt();
		int i2 = bb.getInt();
		
		solution = new Dwg12Table();
		solution.s1 = s1;
		solution.i1 = i1;
		solution.i2 = i2;
		return solution;
	}
	
	
	class Dwg12TableTest{
		short s1, s2, s3;
		int i1;
	}
	public Dwg12TableTest getTableTest(){
		Dwg12TableTest solution = null;
		
		
		bb.order(ByteOrder.LITTLE_ENDIAN);
		short s1 = bb.getShort();
		short s2 = bb.getShort();
		short s3 = bb.getShort();
		int i1 = bb.getInt();
		
		solution = new Dwg12TableTest();
		solution.s1 = s1;
		solution.s2 = s2;
		solution.s3 = s3;
		solution.i1 = i1;
		
		return solution;
	}

	/* (non-Javadoc)
	 * @see com.iver.cit.jdwglib.dwg.readers.IDwgFileReader#readObjectHeader(int[], int, com.iver.cit.jdwglib.dwg.DwgObject)
	 */
	public int readObjectHeader(int[] data, int offset, DwgObject dwgObject) throws RuntimeException, CorruptedDwgEntityException {
		return 0;
	}

	/* (non-Javadoc)
	 * @see com.iver.cit.jdwglib.dwg.readers.IDwgFileReader#readObjectTailer(int[], int, com.iver.cit.jdwglib.dwg.DwgObject)
	 */
	public int readObjectTailer(int[] data, int offset, DwgObject dwgObject) throws RuntimeException, CorruptedDwgEntityException {
		return 0;
	}

}
