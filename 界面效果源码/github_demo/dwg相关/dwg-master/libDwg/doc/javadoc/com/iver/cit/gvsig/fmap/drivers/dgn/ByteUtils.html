<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_08) on Wed Sep 07 16:36:35 CEST 2005 -->
<TITLE>
ByteUtils
</TITLE>

<META NAME="keywords" CONTENT="com.iver.cit.gvsig.fmap.drivers.dgn.ByteUtils class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ByteUtils";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ByteUtils.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ByteUtils.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.iver.cit.gvsig.fmap.drivers.dgn</FONT>
<BR>
Class ByteUtils</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../../../resources/inherit.gif" ALT="extended by"><B>com.iver.cit.gvsig.fmap.drivers.dgn.ByteUtils</B>
</PRE>
<HR>
<DL>
<DT>public class <B>ByteUtils</B><DT>extends java.lang.Object</DL>

<P>
Clase que engloba métodos para trabajar con bytes.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Vicente Caballero Navarro</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#digits">digits</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A nibble->char mapping for printing out bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#SIZE_BOOL">SIZE_BOOL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#SIZE_DOUBLE">SIZE_DOUBLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#SIZE_INT">SIZE_INT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#SIZE_LONG">SIZE_LONG</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#SIZE_SHORT">SIZE_SHORT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#ByteUtils()">ByteUtils</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#bigIntegerToBytes(java.math.BigInteger, byte[], int[])">bigIntegerToBytes</A></B>(java.math.BigInteger&nbsp;n,
                  byte[]&nbsp;data,
                  int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write the bytes representing <code>n</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#boolToBytes(boolean, byte[], int[])">boolToBytes</A></B>(boolean&nbsp;b,
            byte[]&nbsp;data,
            int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write the bytes representing <code>b</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.math.BigInteger</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#bytesToBigInteger(byte[], int[])">bytesToBigInteger</A></B>(byte[]&nbsp;data,
                  int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the <code>BigInteger</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#bytesToBool(byte[], int[])">bytesToBool</A></B>(byte[]&nbsp;data,
            int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the <code>boolean</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#bytesToDouble(byte[], int[])">bytesToDouble</A></B>(byte[]&nbsp;data,
              int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the <code>double</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#bytesToInt(byte[], int[])">bytesToInt</A></B>(byte[]&nbsp;data,
           int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the <code>int</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#bytesToInts(int[], int, byte[], int, int)">bytesToInts</A></B>(int[]&nbsp;dst,
            int&nbsp;dst_offset,
            byte[]&nbsp;src,
            int&nbsp;src_offset,
            int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convert an array of <code>bytes</code>s into an array of
 <code>ints</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#bytesToLong(byte[], int[])">bytesToLong</A></B>(byte[]&nbsp;data,
            int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the <code>long</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;short</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#bytesToShort(byte[], int[])">bytesToShort</A></B>(byte[]&nbsp;data,
             int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the <code>short</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#bytesToString(byte[], int[])">bytesToString</A></B>(byte[]&nbsp;data,
              int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the <code>String</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#byteToUnsignedInt(byte)">byteToUnsignedInt</A></B>(byte&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convert a <code>byte</code> into an unsigned integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#doubleToBytes(double, byte[], int[])">doubleToBytes</A></B>(double&nbsp;d,
              byte[]&nbsp;data,
              int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write the bytes representing <code>d</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#equals(byte[], byte[])">equals</A></B>(byte[]&nbsp;b1,
       byte[]&nbsp;b2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines whether two arrays of <code>byte</code>s contain the same
 contents.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#getUnsigned(byte)">getUnsigned</A></B>(byte&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOCUMENT ME!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#intsToBytes(byte[], int, int[], int, int)">intsToBytes</A></B>(byte[]&nbsp;dst,
            int&nbsp;dst_offset,
            int[]&nbsp;src,
            int&nbsp;src_offset,
            int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convert an array of <code>int</code>s into an array of
 <code>bytes</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#intToBytes(int, byte[], int[])">intToBytes</A></B>(int&nbsp;i,
           byte[]&nbsp;data,
           int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write the bytes representing <code>i</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#longToBytes(long, byte[], int[])">longToBytes</A></B>(long&nbsp;l,
            byte[]&nbsp;data,
            int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write the bytes representing <code>l</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#memclr(byte[], int, int)">memclr</A></B>(byte[]&nbsp;array,
       int&nbsp;offset,
       int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fill the given array with zeros.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#memcmp(byte[], int, byte[], int, int)">memcmp</A></B>(byte[]&nbsp;a,
       int&nbsp;a_offset,
       byte[]&nbsp;b,
       int&nbsp;b_offset,
       int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compare the contents of one array of <code>bytes</code> to another.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#memcpy(byte[], int, byte[], int, int)">memcpy</A></B>(byte[]&nbsp;dst,
       int&nbsp;dst_offset,
       byte[]&nbsp;src,
       int&nbsp;src_offset,
       int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy contents of one array of <code>bytes</code> into another. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#print_bytes_exact(byte[], int, int)">print_bytes_exact</A></B>(byte[]&nbsp;data,
                  int&nbsp;offset,
                  int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOCUMENT ME!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#print_bytes(byte[])">print_bytes</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOCUMENT ME!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#print_bytes(byte[], int, int)">print_bytes</A></B>(byte[]&nbsp;data,
            int&nbsp;offset,
            int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Produce a <code>String</code> representation for the specified array of
 <code>byte</code>s.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#round_up(int, int)">round_up</A></B>(int&nbsp;value,
         int&nbsp;multiple)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Round a number up to a given multiple.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#shortToBytes(short, byte[], int[])">shortToBytes</A></B>(short&nbsp;s,
             byte[]&nbsp;data,
             int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write the bytes representing <code>s</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#stringToBytes(java.lang.String, byte[], int[])">stringToBytes</A></B>(java.lang.String&nbsp;s,
              byte[]&nbsp;data,
              int[]&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write the bytes representing <code>s</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/iver/cit/gvsig/fmap/drivers/dgn/ByteUtils.html#zero_pad(byte[], int)">zero_pad</A></B>(byte[]&nbsp;original,
         int&nbsp;block_size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a new array equal to original except zero-padded to an integral
 mulitple of blocks.  </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="SIZE_BOOL"><!-- --></A><H3>
SIZE_BOOL</H3>
<PRE>
public static final int <B>SIZE_BOOL</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../../constant-values.html#com.iver.cit.gvsig.fmap.drivers.dgn.ByteUtils.SIZE_BOOL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SIZE_SHORT"><!-- --></A><H3>
SIZE_SHORT</H3>
<PRE>
public static final int <B>SIZE_SHORT</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../../constant-values.html#com.iver.cit.gvsig.fmap.drivers.dgn.ByteUtils.SIZE_SHORT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SIZE_INT"><!-- --></A><H3>
SIZE_INT</H3>
<PRE>
public static final int <B>SIZE_INT</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../../constant-values.html#com.iver.cit.gvsig.fmap.drivers.dgn.ByteUtils.SIZE_INT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SIZE_LONG"><!-- --></A><H3>
SIZE_LONG</H3>
<PRE>
public static final int <B>SIZE_LONG</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../../constant-values.html#com.iver.cit.gvsig.fmap.drivers.dgn.ByteUtils.SIZE_LONG">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SIZE_DOUBLE"><!-- --></A><H3>
SIZE_DOUBLE</H3>
<PRE>
public static final int <B>SIZE_DOUBLE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../../constant-values.html#com.iver.cit.gvsig.fmap.drivers.dgn.ByteUtils.SIZE_DOUBLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="digits"><!-- --></A><H3>
digits</H3>
<PRE>
public static final char[] <B>digits</B></PRE>
<DL>
<DD>A nibble->char mapping for printing out bytes.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="ByteUtils()"><!-- --></A><H3>
ByteUtils</H3>
<PRE>
public <B>ByteUtils</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="bytesToInt(byte[], int[])"><!-- --></A><H3>
bytesToInt</H3>
<PRE>
public static final int <B>bytesToInt</B>(byte[]&nbsp;data,
                                   int[]&nbsp;offset)</PRE>
<DL>
<DD>Return the <code>int</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - the array from which to read<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data from which to begin reading on function entry, and which on
 		  function exit has been incremented by the number of bytes read.
<DT><B>Returns:</B><DD>the value of the <code>int</code> decoded</DL>
</DD>
</DL>
<HR>

<A NAME="intToBytes(int, byte[], int[])"><!-- --></A><H3>
intToBytes</H3>
<PRE>
public static final void <B>intToBytes</B>(int&nbsp;i,
                                    byte[]&nbsp;data,
                                    int[]&nbsp;offset)</PRE>
<DL>
<DD>Write the bytes representing <code>i</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the <code>int</code> to encode<DD><CODE>data</CODE> - The byte array to store into, or <code>null</code>.<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data to begin writing at on function entry, and which on
 		  function exit has been incremented by the number of bytes
 		  written.</DL>
</DD>
</DL>
<HR>

<A NAME="bytesToShort(byte[], int[])"><!-- --></A><H3>
bytesToShort</H3>
<PRE>
public static final short <B>bytesToShort</B>(byte[]&nbsp;data,
                                       int[]&nbsp;offset)</PRE>
<DL>
<DD>Return the <code>short</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - the array from which to read<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data from which to begin reading on function entry, and which on
 		  function exit has been incremented by the number of bytes read.
<DT><B>Returns:</B><DD>the value of the <code>short</code> decoded</DL>
</DD>
</DL>
<HR>

<A NAME="shortToBytes(short, byte[], int[])"><!-- --></A><H3>
shortToBytes</H3>
<PRE>
public static final void <B>shortToBytes</B>(short&nbsp;s,
                                      byte[]&nbsp;data,
                                      int[]&nbsp;offset)</PRE>
<DL>
<DD>Write the bytes representing <code>s</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - the <code>short</code> to encode<DD><CODE>data</CODE> - The byte array to store into, or <code>null</code>.<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data to begin writing at on function entry, and which on
 		  function exit has been incremented by the number of bytes
 		  written.</DL>
</DD>
</DL>
<HR>

<A NAME="bytesToLong(byte[], int[])"><!-- --></A><H3>
bytesToLong</H3>
<PRE>
public static final long <B>bytesToLong</B>(byte[]&nbsp;data,
                                     int[]&nbsp;offset)</PRE>
<DL>
<DD>Return the <code>long</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - the array from which to read<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data from which to begin reading on  function entry, and which
 		  on function exit has been incremented by the number of bytes
 		  read.
<DT><B>Returns:</B><DD>the value of the <code>long</code> decoded</DL>
</DD>
</DL>
<HR>

<A NAME="longToBytes(long, byte[], int[])"><!-- --></A><H3>
longToBytes</H3>
<PRE>
public static final void <B>longToBytes</B>(long&nbsp;l,
                                     byte[]&nbsp;data,
                                     int[]&nbsp;offset)</PRE>
<DL>
<DD>Write the bytes representing <code>l</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>l</CODE> - the <code>long</code> to encode<DD><CODE>data</CODE> - The byte array to store into, or <code>null</code>.<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data to begin writing at on function entry, and which on
 		  function exit has been incremented by the number of bytes
 		  written.</DL>
</DD>
</DL>
<HR>

<A NAME="bytesToDouble(byte[], int[])"><!-- --></A><H3>
bytesToDouble</H3>
<PRE>
public static final double <B>bytesToDouble</B>(byte[]&nbsp;data,
                                         int[]&nbsp;offset)</PRE>
<DL>
<DD>Return the <code>double</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - the array from which to read<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data from which to begin reading on  function entry, and which
 		  on function exit has been incremented by the number of bytes
 		  read.
<DT><B>Returns:</B><DD>the value of the <code>double</code> decoded</DL>
</DD>
</DL>
<HR>

<A NAME="doubleToBytes(double, byte[], int[])"><!-- --></A><H3>
doubleToBytes</H3>
<PRE>
public static final void <B>doubleToBytes</B>(double&nbsp;d,
                                       byte[]&nbsp;data,
                                       int[]&nbsp;offset)</PRE>
<DL>
<DD>Write the bytes representing <code>d</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>d</CODE> - the <code>double</code> to encode<DD><CODE>data</CODE> - The byte array to store into, or <code>null</code>.<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data to begin writing at on function entry, and which on
 		  function exit has been incremented by the number of bytes
 		  written.</DL>
</DD>
</DL>
<HR>

<A NAME="bytesToString(byte[], int[])"><!-- --></A><H3>
bytesToString</H3>
<PRE>
public static final java.lang.String <B>bytesToString</B>(byte[]&nbsp;data,
                                                   int[]&nbsp;offset)</PRE>
<DL>
<DD>Return the <code>String</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>. This method
 relies on the user using the corresponding <code>stringToBytes</code>
 method to encode the <code>String</code>, so that it may properly
 retrieve the <code>String</code> length.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - the array from which to read<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data from which to begin reading on function entry, and which on
 		  function exit has been incremented by the number of bytes read.
<DT><B>Returns:</B><DD>the value of the <code>String</code> decoded</DL>
</DD>
</DL>
<HR>

<A NAME="stringToBytes(java.lang.String, byte[], int[])"><!-- --></A><H3>
stringToBytes</H3>
<PRE>
public static final void <B>stringToBytes</B>(java.lang.String&nbsp;s,
                                       byte[]&nbsp;data,
                                       int[]&nbsp;offset)</PRE>
<DL>
<DD>Write the bytes representing <code>s</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - the <code>String</code> to encode<DD><CODE>data</CODE> - The byte array to store into, or <code>null</code>.<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data to begin writing at on function entry, and which on
 		  function exit has been incremented by the number of bytes
 		  written.</DL>
</DD>
</DL>
<HR>

<A NAME="bytesToBool(byte[], int[])"><!-- --></A><H3>
bytesToBool</H3>
<PRE>
public static final boolean <B>bytesToBool</B>(byte[]&nbsp;data,
                                        int[]&nbsp;offset)</PRE>
<DL>
<DD>Return the <code>boolean</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - the array from which to read<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data from which to begin reading on  function entry, and which
 		  on function exit has been incremented by the number of bytes
 		  read.
<DT><B>Returns:</B><DD>the value of the <code>boolean</code> decoded</DL>
</DD>
</DL>
<HR>

<A NAME="boolToBytes(boolean, byte[], int[])"><!-- --></A><H3>
boolToBytes</H3>
<PRE>
public static final void <B>boolToBytes</B>(boolean&nbsp;b,
                                     byte[]&nbsp;data,
                                     int[]&nbsp;offset)</PRE>
<DL>
<DD>Write the bytes representing <code>b</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>b</CODE> - the <code>boolean</code> to encode<DD><CODE>data</CODE> - The byte array to store into, or <code>null</code>.<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data to begin writing at on function entry, and which on
 		  function exit has been incremented by the number of bytes
 		  written.</DL>
</DD>
</DL>
<HR>

<A NAME="bytesToBigInteger(byte[], int[])"><!-- --></A><H3>
bytesToBigInteger</H3>
<PRE>
public static final java.math.BigInteger <B>bytesToBigInteger</B>(byte[]&nbsp;data,
                                                           int[]&nbsp;offset)</PRE>
<DL>
<DD>Return the <code>BigInteger</code> represented by the bytes in
 <code>data</code> staring at offset <code>offset[0]</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - the array from which to read<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data from which to begin reading on  function entry, and which
 		  on function exit has been incremented by the number of bytes
 		  read.
<DT><B>Returns:</B><DD>the <code>BigInteger</code> decoded</DL>
</DD>
</DL>
<HR>

<A NAME="bigIntegerToBytes(java.math.BigInteger, byte[], int[])"><!-- --></A><H3>
bigIntegerToBytes</H3>
<PRE>
public static final void <B>bigIntegerToBytes</B>(java.math.BigInteger&nbsp;n,
                                           byte[]&nbsp;data,
                                           int[]&nbsp;offset)</PRE>
<DL>
<DD>Write the bytes representing <code>n</code> into the byte array
 <code>data</code>, starting at index <code>offset [0]</code>, and
 increment <code>offset [0]</code> by the number of bytes written; if
 <code>data == null</code>, increment <code>offset [0]</code> by the
 number of bytes that would have been written otherwise.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the <code>BigInteger</code> to encode<DD><CODE>data</CODE> - The byte array to store into, or <code>null</code>.<DD><CODE>offset</CODE> - A single element array whose first element is the index in
 		  data to begin writing at on function entry, and which on
 		  function exit has been incremented by the number of bytes
 		  written.</DL>
</DD>
</DL>
<HR>

<A NAME="bytesToInts(int[], int, byte[], int, int)"><!-- --></A><H3>
bytesToInts</H3>
<PRE>
public static final void <B>bytesToInts</B>(int[]&nbsp;dst,
                                     int&nbsp;dst_offset,
                                     byte[]&nbsp;src,
                                     int&nbsp;src_offset,
                                     int&nbsp;length)</PRE>
<DL>
<DD>Convert an array of <code>bytes</code>s into an array of
 <code>ints</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - the array to write<DD><CODE>dst_offset</CODE> - the start offset in <code>dst</code>, times 4. This
 		  measures the offset as if <code>dst</code> were an array of
 		  <code>byte</code>s (rather than <code>int</code>s).<DD><CODE>src</CODE> - the array to read<DD><CODE>src_offset</CODE> - the start offset in <code>src</code><DD><CODE>length</CODE> - the number of <code>byte</code>s to copy.</DL>
</DD>
</DL>
<HR>

<A NAME="intsToBytes(byte[], int, int[], int, int)"><!-- --></A><H3>
intsToBytes</H3>
<PRE>
public static final void <B>intsToBytes</B>(byte[]&nbsp;dst,
                                     int&nbsp;dst_offset,
                                     int[]&nbsp;src,
                                     int&nbsp;src_offset,
                                     int&nbsp;length)</PRE>
<DL>
<DD>Convert an array of <code>int</code>s into an array of
 <code>bytes</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - the array to write<DD><CODE>dst_offset</CODE> - the start offset in <code>dst</code><DD><CODE>src</CODE> - the array to read<DD><CODE>src_offset</CODE> - the start offset in <code>src</code>, times 4. This
 		  measures the offset as if <code>src</code> were an array of
 		  <code>byte</code>s (rather than <code>int</code>s).<DD><CODE>length</CODE> - the number of <code>byte</code>s to copy.</DL>
</DD>
</DL>
<HR>

<A NAME="byteToUnsignedInt(byte)"><!-- --></A><H3>
byteToUnsignedInt</H3>
<PRE>
public static final int <B>byteToUnsignedInt</B>(byte&nbsp;b)</PRE>
<DL>
<DD>Convert a <code>byte</code> into an unsigned integer.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>b</CODE> - the <code>byte</code> to cast
<DT><B>Returns:</B><DD>a postiive <code>int</code> whose lowest byte contains the bits
 		   of <code>b</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="memcpy(byte[], int, byte[], int, int)"><!-- --></A><H3>
memcpy</H3>
<PRE>
public static int <B>memcpy</B>(byte[]&nbsp;dst,
                         int&nbsp;dst_offset,
                         byte[]&nbsp;src,
                         int&nbsp;src_offset,
                         int&nbsp;length)</PRE>
<DL>
<DD>Copy contents of one array of <code>bytes</code> into another. If either
 array is <code>null</code>, simply return the <code>length</code>
 parameter directly.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - the array to write, or <code>null</code><DD><CODE>dst_offset</CODE> - the start offset in <code>dst</code><DD><CODE>src</CODE> - the array to read, or <code>null</code><DD><CODE>src_offset</CODE> - the start offset in <code>src</code><DD><CODE>length</CODE> - the number of <code>byte</code>s to copy.
<DT><B>Returns:</B><DD>DOCUMENT ME!</DL>
</DD>
</DL>
<HR>

<A NAME="memcmp(byte[], int, byte[], int, int)"><!-- --></A><H3>
memcmp</H3>
<PRE>
public static boolean <B>memcmp</B>(byte[]&nbsp;a,
                             int&nbsp;a_offset,
                             byte[]&nbsp;b,
                             int&nbsp;b_offset,
                             int&nbsp;length)</PRE>
<DL>
<DD>Compare the contents of one array of <code>bytes</code> to another.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the first array<DD><CODE>a_offset</CODE> - the start offset in <code>a</code><DD><CODE>b</CODE> - the second array<DD><CODE>b_offset</CODE> - the start offset in <code>b</code><DD><CODE>length</CODE> - the number of <code>byte</code>s to compare.
<DT><B>Returns:</B><DD>DOCUMENT ME!</DL>
</DD>
</DL>
<HR>

<A NAME="memclr(byte[], int, int)"><!-- --></A><H3>
memclr</H3>
<PRE>
public static void <B>memclr</B>(byte[]&nbsp;array,
                          int&nbsp;offset,
                          int&nbsp;length)</PRE>
<DL>
<DD>Fill the given array with zeros.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the array to clear<DD><CODE>offset</CODE> - the start offset<DD><CODE>length</CODE> - the number of <code>byte</code>s to clear.</DL>
</DD>
</DL>
<HR>

<A NAME="round_up(int, int)"><!-- --></A><H3>
round_up</H3>
<PRE>
public static int <B>round_up</B>(int&nbsp;value,
                           int&nbsp;multiple)</PRE>
<DL>
<DD>Round a number up to a given multiple.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - the number to be rounded<DD><CODE>multiple</CODE> - the number to which to be rounded
<DT><B>Returns:</B><DD>the smallest <code>int</code> greater than or equal to
 		   <code>value</code> which divides <code>multiple</code> exactly.</DL>
</DD>
</DL>
<HR>

<A NAME="zero_pad(byte[], int)"><!-- --></A><H3>
zero_pad</H3>
<PRE>
public static byte[] <B>zero_pad</B>(byte[]&nbsp;original,
                              int&nbsp;block_size)</PRE>
<DL>
<DD>Return a new array equal to original except zero-padded to an integral
 mulitple of blocks.  If the original is already an integral multiple of
 blocks, just return it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>original</CODE> - the array of <code>byte</code>s to be padded<DD><CODE>block_size</CODE> - the size of the blocks
<DT><B>Returns:</B><DD>an array whose size divides <code>block_size</code> exactly. The
 		   array is either <code>original</code> itself, or a copy whose
 		   first <code>original.length</code> bytes are equal to
 		   <code>original</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="equals(byte[], byte[])"><!-- --></A><H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(byte[]&nbsp;b1,
                             byte[]&nbsp;b2)</PRE>
<DL>
<DD>Determines whether two arrays of <code>byte</code>s contain the same
 contents.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>b1</CODE> - The first array<DD><CODE>b2</CODE> - The second array
<DT><B>Returns:</B><DD><code>true</code> if both arrays are <code>null</code>, both
 		   empty, or both of the same length with equal contents.</DL>
</DD>
</DL>
<HR>

<A NAME="print_bytes(byte[], int, int)"><!-- --></A><H3>
print_bytes</H3>
<PRE>
public static java.lang.String <B>print_bytes</B>(byte[]&nbsp;data,
                                           int&nbsp;offset,
                                           int&nbsp;length)</PRE>
<DL>
<DD>Produce a <code>String</code> representation for the specified array of
 <code>byte</code>s.  Print each <code>byte</code> as two hexadecimal
 digits.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - The array to print<DD><CODE>offset</CODE> - the start offset in <code>data</code><DD><CODE>length</CODE> - the number of <code>byte</code>s to print
<DT><B>Returns:</B><DD>DOCUMENT ME!</DL>
</DD>
</DL>
<HR>

<A NAME="print_bytes_exact(byte[], int, int)"><!-- --></A><H3>
print_bytes_exact</H3>
<PRE>
public static java.lang.String <B>print_bytes_exact</B>(byte[]&nbsp;data,
                                                 int&nbsp;offset,
                                                 int&nbsp;length)</PRE>
<DL>
<DD>DOCUMENT ME!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - DOCUMENT ME!<DD><CODE>offset</CODE> - DOCUMENT ME!<DD><CODE>length</CODE> - DOCUMENT ME!
<DT><B>Returns:</B><DD>DOCUMENT ME!</DL>
</DD>
</DL>
<HR>

<A NAME="print_bytes(byte[])"><!-- --></A><H3>
print_bytes</H3>
<PRE>
public static java.lang.String <B>print_bytes</B>(byte[]&nbsp;data)</PRE>
<DL>
<DD>DOCUMENT ME!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - DOCUMENT ME!
<DT><B>Returns:</B><DD>DOCUMENT ME!</DL>
</DD>
</DL>
<HR>

<A NAME="getUnsigned(byte)"><!-- --></A><H3>
getUnsigned</H3>
<PRE>
public static int <B>getUnsigned</B>(byte&nbsp;b)</PRE>
<DL>
<DD>DOCUMENT ME!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>b</CODE> - DOCUMENT ME!
<DT><B>Returns:</B><DD>DOCUMENT ME!</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ByteUtils.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ByteUtils.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
